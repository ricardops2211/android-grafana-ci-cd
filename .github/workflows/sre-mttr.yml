name: SRE-MTTR-Lab-Richie

on:
  push:
    branches: ["nuevo-sre-richie"]
  workflow_dispatch: {}

jobs:
  lab:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      # Kubeconfig persistente en el workspace del job
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

      # Endpoints / credenciales (como Secrets de GitHub)
      GC_PROM_URL: ${{ secrets.GC_PROM_URL }}
      GC_PROM_USERNAME: ${{ secrets.GC_PROM_USERNAME }}
      GC_PROM_PASSWORD: ${{ secrets.GC_PROM_PASSWORD }}

      GC_LOKI_URL: ${{ secrets.GC_LOKI_URL }}
      GC_LOKI_USERNAME: ${{ secrets.GC_LOKI_USERNAME }}
      GC_LOKI_PASSWORD: ${{ secrets.GC_LOKI_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Instalar kind / kubectl / helm / utilidades
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq curl ca-certificates gnupg gettext-base
          curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -Lo kind https://kind.sigs.k8s.io/dl/v0.23.0/kind-linux-amd64
          chmod +x kind && sudo mv kind /usr/local/bin/
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Crear clúster Kind y kubeconfig
        run: |
          set -e
          cat > kind.yaml <<'YAML'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
          YAML
          kind create cluster --name sre-mttr --config kind.yaml
          kind get kubeconfig --name sre-mttr > "$KUBECONFIG"
          chmod 600 "$KUBECONFIG"
          kubectl config use-context kind-sre-mttr
          # Esperas rápidas
          for i in {1..30}; do
            if kubectl version --short >/dev/null 2>&1; then break; fi
            echo "⏳ Esperando API server..."
            sleep 2
          done
          kubectl get nodes -o wide
          kubectl wait --for=condition=Ready nodes --all --timeout=180s

      - name: Namespaces
        run: |
          kubectl create ns monitoring || true
          kubectl create ns demo-app || true

      - name: Secret credenciales Grafana Cloud (Prometheus)
        run: |
          kubectl -n monitoring delete secret grafana-cloud-metrics || true
          kubectl -n monitoring create secret generic grafana-cloud-metrics \
            --from-literal=username="${GC_PROM_USERNAME}" \
            --from-literal=password="${GC_PROM_PASSWORD}"

      - name: Agregar repos Helm
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update

      - name: Instalar kube-prometheus-stack (con remote_write → Grafana Cloud)
        run: |
          # Renderiza variables de entorno en el values (usa ${GC_PROM_URL})
          envsubst < infra/helm/values-prom.yaml > /tmp/values-prom.evaluated.yaml
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            -n monitoring \
            -f /tmp/values-prom.evaluated.yaml \
            --wait --timeout 20m

      - name: Instalar Promtail apuntando a Grafana Cloud Loki
        run: |
          envsubst < infra/helm/values-loki.yaml > /tmp/values-loki.evaluated.yaml
          helm upgrade --install loki grafana/loki-stack \
            -n monitoring \
            -f /tmp/values-loki.evaluated.yaml \
            --set loki.enabled=false \
            --wait --timeout 15m

      - name: Desplegar app y reglas/alertas
        run: |
          kubectl apply -f k8s/app/podinfo.yaml
          kubectl apply -f k8s/alerts/mttr-recording-rules.yaml
          # Espera a que la app esté lista inicialmente
          kubectl -n demo-app rollout status deploy/podinfo --timeout=5m

      - name: Inyectar incidente y medir MTTR
        id: mttr
        shell: bash
        run: |
          set -euo pipefail
          NS="demo-app"; DEPLOY="podinfo"

          START=$(date +%s)
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=0
          sleep 90
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=2
          kubectl -n "$NS" rollout status deploy/"$DEPLOY" --timeout=5m
          END=$(date +%s)

          MTTR_SEC=$((END-START)); (( MTTR_SEC<0 )) && MTTR_SEC=0
          START_MS=$((START*1000)); END_MS=$((END*1000))

          echo "mttr_sec=${MTTR_SEC}"       >> "$GITHUB_OUTPUT"
          echo "start_ms=${START_MS}"       >> "$GITHUB_OUTPUT"
          echo "end_ms=${END_MS}"           >> "$GITHUB_OUTPUT"

          # (Opcional) publicar en Loki (ya lo tienes resuelto)
          TS_NS=$(($(date +%s%N)))
          LOG_LINE=$(jq -nc --argjson mttr "$MTTR_SEC" \
            '{"mttr_seconds":$mttr,"message":"MTTR (kind→Grafana Cloud)","incidents_resolved":1}')
          RESP=$(curl -sS -w "\n%{http_code}" -u "${GC_LOKI_USERNAME}:${GC_LOKI_PASSWORD}" \
            -H "Content-Type: application/json" -X POST "${GC_LOKI_URL}" \
            --data "{\"streams\":[{\"stream\":{\"app\":\"podinfo\",\"metric\":\"mttr\"},\"values\":[[\"${TS_NS}\",\"${LOG_LINE}\"]]}]}")
          CODE=$(echo "$RESP" | tail -n1); [[ "$CODE" =~ ^20(0|4)$ ]] || { echo "::warning::Push a Loki devolvió $CODE"; }

      - name: Crear anotación en Grafana (stack UI) con MTTR
        shell: bash
        env:
          GRAFANA_URL: https://ricardops2211.grafana.net
          GC_GRAFANA_API_TOKEN: ${{ secrets.GC_GRAFANA_API_TOKEN }}
        run: |
          set -euo pipefail

          # Validaciones claras para evitar abortar “en seco”
          : "${GC_GRAFANA_API_TOKEN:?Falta GC_GRAFANA_API_TOKEN (Service Account token con rol Editor)}"
          : "${GRAFANA_URL:?Falta GRAFANA_URL (https://<stack>.grafana.net)}"

          MTTR_SEC="${{ steps.mttr.outputs.mttr_sec }}"
          START_MS="${{ steps.mttr.outputs.start_ms }}"
          END_MS="${{ steps.mttr.outputs.end_ms }}"

          if [[ -z "$MTTR_SEC" || -z "$START_MS" || -z "$END_MS" ]]; then
            echo "::error::No llegaron outputs del step 'mttr' (mttr_sec/start_ms/end_ms)."
            exit 1
          fi

          read -r -d '' PAYLOAD <<EOF
          {
            "time": ${START_MS},
            "timeEnd": ${END_MS},
            "text": "MTTR demo: ${MTTR_SEC}s",
            "tags": ["mttr","sre","podinfo"]
          }
          EOF

          RESP=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GC_GRAFANA_API_TOKEN}" \
            -H "Content-Type: application/json" \
            -X POST "${GRAFANA_URL}/api/annotations" \
            --data "${PAYLOAD}")

          BODY=$(echo "$RESP" | head -n-1)
          CODE=$(echo "$RESP" | tail -n1)

          if [[ "$CODE" != "200" && "$CODE" != "202" ]]; then
            echo "::error::❌ Falló la anotación (HTTP $CODE)"
            echo "$BODY"
            echo "Causas típicas:"
            echo "  • Token NO es Service Account (usa uno con rol Editor/Admin)."
            echo "  • URL del stack incorrecta (usa https://<stack>.grafana.net)."
            echo "  • 'time' y 'timeEnd' deben ir en milisegundos."
            exit 1
          fi

          echo "✅ Anotación creada: $BODY"
