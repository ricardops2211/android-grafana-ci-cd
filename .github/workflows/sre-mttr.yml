name: SRE-MTTR-Lab-Richie

on:
  push:
    branches: ["nuevo-sre-richie"]
  workflow_dispatch: {}

jobs:
  lab:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      # Kubeconfig persistente en el workspace del job
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

      # Endpoints / credenciales (como Secrets de GitHub)
      GC_PROM_URL: ${{ secrets.GC_PROM_URL }}
      GC_PROM_USERNAME: ${{ secrets.GC_PROM_USERNAME }}
      GC_PROM_PASSWORD: ${{ secrets.GC_PROM_PASSWORD }}

      GC_LOKI_URL: ${{ secrets.GC_LOKI_URL }}
      GC_LOKI_USERNAME: ${{ secrets.GC_LOKI_USERNAME }}
      GC_LOKI_PASSWORD: ${{ secrets.GC_LOKI_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Instalar kind / kubectl / helm / utilidades
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq curl ca-certificates gnupg gettext-base
          curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -Lo kind https://kind.sigs.k8s.io/dl/v0.23.0/kind-linux-amd64
          chmod +x kind && sudo mv kind /usr/local/bin/
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Crear clúster Kind y kubeconfig
        run: |
          set -e
          cat > kind.yaml <<'YAML'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
          YAML
          kind create cluster --name sre-mttr --config kind.yaml
          kind get kubeconfig --name sre-mttr > "$KUBECONFIG"
          chmod 600 "$KUBECONFIG"
          kubectl config use-context kind-sre-mttr
          # Esperas rápidas
          for i in {1..30}; do
            if kubectl version --short >/dev/null 2>&1; then break; fi
            echo "⏳ Esperando API server..."
            sleep 2
          done
          kubectl get nodes -o wide
          kubectl wait --for=condition=Ready nodes --all --timeout=180s

      - name: Namespaces
        run: |
          kubectl create ns monitoring || true
          kubectl create ns demo-app || true

      - name: Secret credenciales Grafana Cloud (Prometheus)
        run: |
          kubectl -n monitoring delete secret grafana-cloud-metrics || true
          kubectl -n monitoring create secret generic grafana-cloud-metrics \
            --from-literal=username="${GC_PROM_USERNAME}" \
            --from-literal=password="${GC_PROM_PASSWORD}"

      - name: Agregar repos Helm
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update

      - name: Instalar kube-prometheus-stack (con remote_write → Grafana Cloud)
        run: |
          # Renderiza variables de entorno en el values (usa ${GC_PROM_URL})
          envsubst < infra/helm/values-prom.yaml > /tmp/values-prom.evaluated.yaml
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            -n monitoring \
            -f /tmp/values-prom.evaluated.yaml \
            --wait --timeout 20m

      - name: Instalar Promtail apuntando a Grafana Cloud Loki
        run: |
          envsubst < infra/helm/values-loki.yaml > /tmp/values-loki.evaluated.yaml
          helm upgrade --install loki grafana/loki-stack \
            -n monitoring \
            -f /tmp/values-loki.evaluated.yaml \
            --set loki.enabled=false \
            --wait --timeout 15m

      - name: Desplegar app y reglas/alertas
        run: |
          kubectl apply -f k8s/app/podinfo.yaml
          kubectl apply -f k8s/alerts/mttr-recording-rules.yaml
          # Espera a que la app esté lista inicialmente
          kubectl -n demo-app rollout status deploy/podinfo --timeout=5m

      - name: Inyectar incidente y medir MTTR
        id: mttr
        shell: bash
        run: |
          set -euo pipefail
          NS="demo-app"; DEPLOY="podinfo"
          START=$(date +%s)
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=0
          sleep 90
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=2
          kubectl -n "$NS" rollout status deploy/"$DEPLOY" --timeout=5m
          END=$(date +%s)
          MTTR_SEC=$((END-START)); (( MTTR_SEC<0 )) && MTTR_SEC=0
          START_MS=$((START*1000)); END_MS=$((END*1000))
          echo "mttr_sec=${MTTR_SEC}" >> "$GITHUB_OUTPUT"
          echo "start_ms=${START_MS}" >> "$GITHUB_OUTPUT"
          echo "end_ms=${END_MS}"     >> "$GITHUB_OUTPUT"

      - name: Publicar MTTR en Loki Cloud (payload seguro con jq)
        shell: bash
        env:
          GC_LOKI_URL: ${{ secrets.GC_LOKI_URL }}
          GC_LOKI_USERNAME: ${{ secrets.GC_LOKI_USERNAME }}
          GC_LOKI_PASSWORD: ${{ secrets.GC_LOKI_PASSWORD }}
        run: |
          set -euo pipefail
          MTTR_SEC="${{ steps.mttr.outputs.mttr_sec }}"
          TS_NS="$(date +%s%N)"
          LINE=$(jq -c -n --argjson mttr "$MTTR_SEC" '{mttr_seconds:$mttr, message:"MTTR (kind→Grafana Cloud)", incidents_resolved:1}')
          PAYLOAD=$(jq -nc --arg ts "$TS_NS" --arg line "$LINE" '{streams:[{stream:{app:"podinfo",metric:"mttr"},values:[[ $ts, $line ]]}]}')
          RESP=$(curl -sS -w "\n%{http_code}" -u "${GC_LOKI_USERNAME}:${GC_LOKI_PASSWORD}" -H "Content-Type: application/json" -X POST "${GC_LOKI_URL}" --data-raw "$PAYLOAD")
          BODY=$(echo "$RESP" | head -n-1); CODE=$(echo "$RESP" | tail -n1)
          echo "HTTP_CODE=$CODE"; [[ -n "$BODY" ]] && echo "RESP_BODY=$BODY"
          if [[ "$CODE" != "204" && "$CODE" != "200" ]]; then
            echo "::error::Push a Loki falló (HTTP $CODE)"; echo "$BODY"; exit 1
          fi
          echo "✅ MTTR publicado en Loki."

      - name: Crear anotación en Grafana (stack UI) con MTTR
        shell: bash
        env:
          GRAFANA_URL: https://ricardops2211.grafana.net
          GC_GRAFANA_API_TOKEN: ${{ secrets.GC_GRAFANA_API_TOKEN }}
        run: |
          # Usamos -e y pipefail, pero NO -u hasta validar envs para evitar abortar "en seco"
          set -e -o pipefail

          # 1) Validaciones claras
          if [[ -z "${GC_GRAFANA_API_TOKEN:-}" ]]; then
            echo "::warning::GC_GRAFANA_API_TOKEN no está definido (Service Account token con rol Editor/Admin). Omitiendo anotación."
            exit 0
          fi
          if [[ -z "${GRAFANA_URL:-}" ]]; then
            echo "::error::Falta GRAFANA_URL (https://<stack>.grafana.net)"; exit 1
          fi

          # 2) Traer outputs del step 'mttr' si existen; si no, fallback
          MTTR_SEC="${{ steps.mttr.outputs.mttr_sec }}"
          START_MS="${{ steps.mttr.outputs.start_ms }}"
          END_MS="${{ steps.mttr.outputs.end_ms }}"

          if [[ -z "${MTTR_SEC:-}" || -z "${START_MS:-}" || -z "${END_MS:-}" ]]; then
            echo "::warning::No llegaron outputs de 'mttr'; usando fallback de 60s en la última 1 min."
            END_MS=$(date +%s%3N)          # epoch ms actual
            START_MS=$((END_MS-60000))     # -60s
            MTTR_SEC=60
          fi

          # 3) Construir payload con jq (JSON siempre válido)
          PAYLOAD=$(jq -nc --argjson t "$START_MS" --argjson te "$END_MS" \
            --arg txt "MTTR demo: ${MTTR_SEC}s" \
            '{time:$t,timeEnd:$te,text:$txt,tags:["mttr","sre","podinfo"]}')

          # 4) Llamar API de Grafana
          RESP=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GC_GRAFANA_API_TOKEN}" \
            -H "Content-Type: application/json" \
            -X POST "${GRAFANA_URL}/api/annotations" \
            --data "$PAYLOAD")

          BODY=$(echo "$RESP" | head -n-1)
          CODE=$(echo "$RESP" | tail -n1)

          echo "HTTP_CODE=$CODE"
          [[ -n "$BODY" ]] && echo "BODY=$BODY"

          if [[ "$CODE" != "200" && "$CODE" != "202" ]]; then
            echo "::error::No se pudo crear la anotación (HTTP $CODE)"
            echo "Causas típicas:"
            echo "  • Token NO es de Service Account del stack (debe ser Editor/Admin)."
            echo "  • URL del stack incorrecta (usa https://<stack>.grafana.net)."
            echo "  • 'time'/'timeEnd' deben ir en MILISEGUNDOS."
            exit 1
          fi

          echo "✅ Anotación creada correctamente."
