name: SRE-MTTR-Lab-Richie

on:
  push:
    branches: ["nuevo-sre-richie"]
  workflow_dispatch: {}

jobs:
  lab:
    runs-on: ubuntu-latest
    timeout-minutes: 60
    env:
      # Kubeconfig persistente en el workspace del job
      KUBECONFIG: ${{ github.workspace }}/kubeconfig

      # Endpoints / credenciales (como Secrets de GitHub)
      GC_PROM_URL: ${{ secrets.GC_PROM_URL }}
      GC_PROM_USERNAME: ${{ secrets.GC_PROM_USERNAME }}
      GC_PROM_PASSWORD: ${{ secrets.GC_PROM_PASSWORD }}

      GC_LOKI_URL: ${{ secrets.GC_LOKI_URL }}
      GC_LOKI_USERNAME: ${{ secrets.GC_LOKI_USERNAME }}
      GC_LOKI_PASSWORD: ${{ secrets.GC_LOKI_PASSWORD }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Instalar kind / kubectl / helm / utilidades
        run: |
          set -e
          sudo apt-get update -y
          sudo apt-get install -y jq curl ca-certificates gnupg gettext-base
          curl -Lo kubectl https://storage.googleapis.com/kubernetes-release/release/$(curl -s https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl
          chmod +x kubectl && sudo mv kubectl /usr/local/bin/
          curl -Lo kind https://kind.sigs.k8s.io/dl/v0.23.0/kind-linux-amd64
          chmod +x kind && sudo mv kind /usr/local/bin/
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Crear cl√∫ster Kind y kubeconfig
        run: |
          set -e
          cat > kind.yaml <<'YAML'
          kind: Cluster
          apiVersion: kind.x-k8s.io/v1alpha4
          nodes:
            - role: control-plane
          YAML
          kind create cluster --name sre-mttr --config kind.yaml
          kind get kubeconfig --name sre-mttr > "$KUBECONFIG"
          chmod 600 "$KUBECONFIG"
          kubectl config use-context kind-sre-mttr
          # Esperas r√°pidas
          for i in {1..30}; do
            if kubectl version --short >/dev/null 2>&1; then break; fi
            echo "‚è≥ Esperando API server..."
            sleep 2
          done
          kubectl get nodes -o wide
          kubectl wait --for=condition=Ready nodes --all --timeout=180s

      - name: Namespaces
        run: |
          kubectl create ns monitoring || true
          kubectl create ns demo-app || true

      - name: Secret credenciales Grafana Cloud (Prometheus)
        run: |
          kubectl -n monitoring delete secret grafana-cloud-metrics || true
          kubectl -n monitoring create secret generic grafana-cloud-metrics \
            --from-literal=username="${GC_PROM_USERNAME}" \
            --from-literal=password="${GC_PROM_PASSWORD}"

      - name: Agregar repos Helm
        run: |
          helm repo add grafana https://grafana.github.io/helm-charts
          helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
          helm repo update

      - name: Instalar kube-prometheus-stack (con remote_write ‚Üí Grafana Cloud)
        run: |
          # Renderiza variables de entorno en el values (usa ${GC_PROM_URL})
          envsubst < infra/helm/values-prom.yaml > /tmp/values-prom.evaluated.yaml
          helm upgrade --install monitoring prometheus-community/kube-prometheus-stack \
            -n monitoring \
            -f /tmp/values-prom.evaluated.yaml \
            --wait --timeout 20m

      - name: Instalar Promtail apuntando a Grafana Cloud Loki
        run: |
          envsubst < infra/helm/values-loki.yaml > /tmp/values-loki.evaluated.yaml
          helm upgrade --install loki grafana/loki-stack \
            -n monitoring \
            -f /tmp/values-loki.evaluated.yaml \
            --set loki.enabled=false \
            --wait --timeout 15m

      - name: Desplegar app y reglas/alertas
        run: |
          kubectl apply -f k8s/app/podinfo.yaml
          kubectl apply -f k8s/alerts/mttr-recording-rules.yaml
          # Espera a que la app est√© lista inicialmente
          kubectl -n demo-app rollout status deploy/podinfo --timeout=5m

      - name: Inyectar incidente y medir MTTR (publica en Loki Cloud)
        id: mttr
        run: |
          set -euo pipefail
          NS="demo-app"
          DEPLOY="podinfo"

          echo "üìå Marcando inicio de incidente‚Ä¶"
          START=$(date +%s)

          echo "üîß Inyectando incidente: replicas=0"
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=0

          echo "‚è≥ Esperando a que la alerta pueda dispararse (for: 1m)‚Ä¶"
          sleep 90

          echo "ü©π Restaurando: replicas=2"
          kubectl -n "$NS" scale deploy "$DEPLOY" --replicas=2
          kubectl -n "$NS" rollout status deploy/"$DEPLOY" --timeout=5m

          END=$(date +%s)
          MTTR_SEC=$((END - START))
          if [ "$MTTR_SEC" -lt 0 ]; then MTTR_SEC=0; fi
          echo "‚úÖ MTTR medido: ${MTTR_SEC}s"

          # Outputs para anotaci√≥n (ms) y para texto (segundos)
          START_MS=$((START * 1000))
          END_MS=$((END * 1000))
          echo "start_ms=$START_MS" >> $GITHUB_OUTPUT
          echo "end_ms=$END_MS" >> $GITHUB_OUTPUT
          echo "mttr_seconds=$MTTR_SEC" >> $GITHUB_OUTPUT

          # Publicar el MTTR en Loki Cloud con Basic Auth (tenant+token)
          TS_NS=$(($(date +%s%N)))
          LOG_LINE=$(jq -nc --argjson mttr "$MTTR_SEC" \
            '{"mttr_seconds":$mttr,"message":"MTTR (kind‚ÜíGrafana Cloud)","incidents_resolved":1}')

          curl -sS -u "${GC_LOKI_USERNAME}:${GC_LOKI_PASSWORD}" \
            -H "Content-Type: application/json" \
            -X POST "${GC_LOKI_URL}" \
            --data "{\"streams\":[{\"stream\":{\"app\":\"podinfo\",\"metric\":\"mttr\"},\"values\":[[\"${TS_NS}\",\"${LOG_LINE}\"]]}]}"

          echo "üß≠ Busca en Grafana Cloud (Explore‚ÜíLoki): {app=\"podinfo\",metric=\"mttr\"}"

      - name: Crear anotaci√≥n en Grafana (stack UI) con MTTR
        env:
          GRAFANA_URL: https://ricardops2211.grafana.net
          GC_GRAFANA_API_TOKEN: ${{ secrets.GC_GRAFANA_API_TOKEN }}
        run: |
          set -euo pipefail

          # Si ya tienes MTTR_SEC en un archivo/env, reutil√≠zalo; aqu√≠ lo re-calculo de ejemplo:
          START=$(date +%s)
          END=$((START + 95))   # <-- reemplaza con tu c√°lculo real
          MTTR_SEC=$((END-START))

          # Timestamps en milisegundos (Grafana los quiere en ms)
          START_MS=$((START*1000))
          END_MS=$((END*1000))

          read -r -d '' PAYLOAD <<EOF
          {
            "time": ${START_MS},
            "timeEnd": ${END_MS},
            "text": "MTTR demo: ${MTTR_SEC}s",
            "tags": ["mttr","sre","podinfo"]
          }
          EOF

          RESP=$(curl -sS -w "\n%{http_code}" \
            -H "Authorization: Bearer ${GC_GRAFANA_API_TOKEN}" \
            -H "Content-Type: application/json" \
            -X POST "${GRAFANA_URL}/api/annotations" \
            --data "${PAYLOAD}")

          BODY=$(echo "$RESP" | head -n-1)
          CODE=$(echo "$RESP" | tail -n1)

          if [[ "$CODE" != "200" && "$CODE" != "202" ]]; then
            echo "::error::‚ùå Fall√≥ la anotaci√≥n (HTTP $CODE)"
            echo "$BODY"
            echo "Causas t√≠picas:"
            echo "  ‚Ä¢ Token no es de Service Account (usa uno con rol Editor/Admin)."
            echo "  ‚Ä¢ URL no es la del stack (usa https://<stack>.grafana.net)."
            echo "  ‚Ä¢ Falta 'Authorization: Bearer <token>' o payload inv√°lido (time en ms)."
            exit 1
          fi

          echo "‚úÖ Anotaci√≥n creada en Grafana: ${BODY}"
