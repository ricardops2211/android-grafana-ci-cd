name: "Loki Port-Forward"
description: "Port-forward al Pod de Loki en 3100 con healthcheck"
inputs:
  namespace:
    description: "Namespace de Loki"
    required: true
    default: "observability"
runs:
  using: "composite"
  steps:
    - shell: bash
      run: |
        set -euo pipefail

        NS="${{ inputs.namespace }}"

        echo "Esperando a que Loki esté Ready..."
        kubectl -n "$NS" wait --for=condition=Ready --timeout=600s pod -l app.kubernetes.io/name=loki

        # Elige un Pod concreto (primer match)
        POD="$(kubectl -n "$NS" get pod -l app.kubernetes.io/name=loki -o jsonpath='{.items[0].metadata.name}')"
        echo "Usaremos el pod: $POD"

        # Arranca el PF en background contra el POD (más fiable que contra el Service)
        kubectl -n "$NS" port-forward pod/"$POD" 3100:3100 >/tmp/pf.log 2>&1 &
        echo $! > /tmp/pf.pid

        # Espera activa hasta que la API de Loki responda
        echo "Chequeando http://127.0.0.1:3100/ready ..."
        for i in {1..60}; do
          if curl -fsS http://127.0.0.1:3100/ready >/dev/null; then
            echo "Loki READY en local"
            break
          fi
          # Si el PF murió, falla rápido
          if ! ps -p "$(cat /tmp/pf.pid)" >/dev/null 2>&1; then
            echo "ERROR: port-forward se detuvo. Logs:"
            sed -n '1,200p' /tmp/pf.log || true
            exit 1
          fi
          sleep 1
        done

        # Chequeo extra de endpoint de status (no obligatorio, pero útil)
        curl -fsS http://127.0.0.1:3100/metrics >/dev/null || true
